<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ –Ω–∞ —Ñ–æ—Ç–æ</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Outfit:wght@300;400;500;600&display=swap');

    :root {
      --bg-dark: #0f0f12;
      --bg-card: #18181c;
      --bg-input: #232328;
      --accent: #7c5cff;
      --accent-hover: #9178ff;
      --success: #34d399;
      --text: #e4e4e7;
      --text-muted: #a1a1aa;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Outfit', sans-serif;
      background: var(--bg-dark);
      color: var(--text);
      min-height: 100vh;
      background-image: 
        radial-gradient(ellipse 80% 50% at 50% -20%, rgba(124, 92, 255, 0.15), transparent),
        radial-gradient(ellipse 60% 40% at 100% 100%, rgba(124, 92, 255, 0.08), transparent);
    }

    .container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 2rem;
    }

    header {
      text-align: center;
      margin-bottom: 3rem;
    }

    h1 {
      font-size: 1.75rem;
      font-weight: 600;
      letter-spacing: -0.02em;
      margin-bottom: 0.5rem;
    }

    .subtitle {
      color: var(--text-muted);
      font-size: 1rem;
      font-weight: 400;
      margin-bottom: 1.5rem;
    }

    .search-row {
      margin-bottom: 1.5rem;
    }

    .object-input {
      width: 100%;
      max-width: 500px;
      display: block;
      margin: 0 auto;
      padding: 0.9rem 1.2rem;
      font-family: inherit;
      font-size: 1rem;
      background: var(--bg-card);
      border: 2px solid var(--bg-input);
      border-radius: 12px;
      color: var(--text);
      transition: border-color 0.2s;
    }

    .object-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .object-input::placeholder {
      color: var(--text-muted);
    }

    .en-labels {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      color: var(--text-muted);
      text-align: center;
      min-height: 1.2em;
    }

    .upload-zone {
      border: 2px dashed var(--bg-input);
      border-radius: 16px;
      padding: 3rem 2rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.25s ease;
      background: var(--bg-card);
      margin-bottom: 2rem;
    }

    .upload-zone:hover, .upload-zone.dragover {
      border-color: var(--accent);
      background: rgba(124, 92, 255, 0.06);
    }

    .upload-zone.has-image {
      padding: 1rem;
    }

    .upload-zone input {
      display: none;
    }

    .upload-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
      opacity: 0.7;
    }

    .upload-text {
      font-size: 1.1rem;
      margin-bottom: 0.25rem;
    }

    .upload-hint {
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .preview-wrapper {
      position: relative;
      display: inline-block;
      overflow: hidden;
      border-radius: 12px;
    }

    #preview {
      max-width: 100%;
      max-height: 400px;
      border-radius: 12px;
      display: block;
      vertical-align: top;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .controls {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin-top: 1.5rem;
      flex-wrap: wrap;
    }

    button {
      font-family: inherit;
      font-size: 0.95rem;
      font-weight: 500;
      padding: 0.6rem 1.25rem;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-detect {
      background: var(--accent);
      color: white;
    }

    .btn-detect:hover:not(:disabled) {
      background: var(--accent-hover);
      transform: translateY(-1px);
    }

    .btn-detect:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-clear {
      background: var(--bg-input);
      color: var(--text);
    }

    .btn-clear:hover {
      background: #2d2d33;
    }

    .btn-masks {
      background: #2d3a4a;
      color: var(--success);
    }

    .btn-masks:hover:not(:disabled) {
      background: #3d4a5a;
    }

    .btn-clipseg {
      background: #2a3d2a;
      color: #7dd87d;
    }

    .btn-clipseg:hover:not(:disabled) {
      background: #3a4d3a;
    }

    .status {
      text-align: center;
      padding: 1rem;
      font-size: 0.95rem;
      color: var(--text-muted);
    }

    .status.loading {
      color: var(--accent);
    }

    .status.success {
      color: var(--success);
    }

    .results-card {
      background: var(--bg-card);
      border-radius: 16px;
      padding: 1.5rem;
      margin-top: 2rem;
    }

    .results-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 1rem;
    }

    .results-list {
      display: grid;
      gap: 0.75rem;
    }

    .result-item {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 1rem;
      background: var(--bg-input);
      border-radius: 10px;
      font-size: 0.95rem;
      gap: 0.25rem;
    }

    .result-class {
      font-weight: 500;
    }

    .result-confidence {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
      color: var(--success);
    }

    .result-item-best {
      border-left: 3px solid var(--success);
    }

    .result-size {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-top: 0.25rem;
    }

    .empty-state {
      text-align: center;
      padding: 2rem;
      color: var(--text-muted);
    }

    .tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 2rem;
      border-bottom: 2px solid var(--bg-input);
    }

    .tab {
      padding: 0.75rem 1.5rem;
      background: none;
      border: none;
      color: var(--text-muted);
      font-family: inherit;
      font-size: 1rem;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      margin-bottom: -2px;
      transition: color 0.2s;
    }

    .tab:hover { color: var(--text); }
    .tab.active { color: var(--accent); border-bottom-color: var(--accent); }

    .tab-panel { display: none; }
    .tab-panel.active { display: block; }

    .variants-upload {
      border: 2px dashed var(--bg-input);
      border-radius: 16px;
      padding: 2rem;
      text-align: center;
      cursor: pointer;
      background: var(--bg-card);
      margin-bottom: 1.5rem;
    }

    .variants-upload:hover { border-color: var(--accent); }

    .variants-controls {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
    }

    .variants-controls label {
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    .variants-sort {
      padding: 0.5rem 1rem;
      font-family: inherit;
      font-size: 0.9rem;
      background: var(--bg-input);
      border: 2px solid var(--bg-card);
      border-radius: 8px;
      color: var(--text);
    }

    .variants-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 1.5rem;
    }

    .variant-card {
      background: var(--bg-card);
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid var(--bg-input);
    }

    .variant-card img {
      width: 100%;
      aspect-ratio: 700 / 900;
      object-fit: cover;
      display: block;
      background: var(--bg-input);
    }

    .variant-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding: 1rem;
    }

    .variant-badge {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      padding: 0.35rem 0.6rem;
      background: var(--bg-input);
      border-radius: 6px;
      color: var(--success);
    }

    .variant-badge.ctr { color: #7c5cff; }
    .variant-badge.views { color: #06b6d4; }
    .variant-badge.abtest { color: #f59e0b; }

    .gen-section { margin-bottom: 1.5rem; }
    .gen-section label { display: block; color: var(--text-muted); font-size: 0.9rem; margin-bottom: 0.5rem; }
    .gen-proxy-input, .gen-prompt-input {
      width: 100%;
      padding: 0.75rem 1rem;
      font-family: inherit;
      font-size: 0.95rem;
      background: var(--bg-input);
      border: 2px solid var(--bg-card);
      border-radius: 10px;
      color: var(--text);
    }
    .gen-prompt-input { min-height: 100px; resize: vertical; }
    .gen-upload {
      border: 2px dashed var(--bg-input);
      border-radius: 12px;
      padding: 1.5rem;
      text-align: center;
      cursor: pointer;
      background: var(--bg-card);
    }
    .gen-upload:hover { border-color: var(--accent); }
    .gen-upload.has-image { border-style: solid; }
    .gen-upload img { max-width: 100%; max-height: 280px; display: block; margin: 0 auto; border-radius: 8px; }
    .gen-result-wrap { margin-top: 1rem; text-align: center; }
    .gen-result-wrap img { max-width: 100%; border-radius: 12px; border: 2px solid var(--bg-input); }
    .gen-btn { margin-top: 1rem; }
    .gen-settings-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 1rem; }
    .gen-setting-wide { grid-column: 1 / -1; }
    .gen-setting label { display: block; font-size: 0.85rem; margin-bottom: 0.35rem; }
    .gen-setting-input { width: 100%; padding: 0.5rem 0.75rem; font-family: inherit; font-size: 0.9rem; background: var(--bg-input); border: 2px solid var(--bg-card); border-radius: 8px; color: var(--text); }
    .gen-setting-hint { display: block; font-size: 0.75rem; color: var(--text-muted); margin-top: 0.25rem; }

    .gen-howto {
      background: var(--bg-card);
      border: 2px solid var(--bg-input);
      border-radius: 12px;
      padding: 0 1rem 1rem;
      margin-bottom: 1.5rem;
    }
    .gen-howto summary {
      cursor: pointer;
      padding: 1rem 0;
      font-weight: 500;
      color: var(--accent);
    }
    .gen-howto ol { margin: 0; padding-left: 1.25rem; color: var(--text-muted); font-size: 0.9rem; line-height: 1.6; }
    .gen-howto li { margin-bottom: 0.5rem; }
    .gen-howto a { color: var(--accent); }
    .gen-howto code { background: var(--bg-input); padding: 0.15rem 0.4rem; border-radius: 4px; font-size: 0.85em; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>AI Vision</h1>
      <p class="subtitle">–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ –∏ –ø—Ä–æ—Å–º–æ—Ç—Ä –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤</p>
    </header>

    <div class="tabs">
      <button class="tab active" data-tab="detect">–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ</button>
      <button class="tab" data-tab="variants">–í–∞—Ä–∏–∞–Ω—Ç—ã</button>
      <button class="tab" data-tab="generate">–ì–µ–Ω–µ—Ä–∞—Ü–∏—è</button>
    </div>

    <div id="panel-detect" class="tab-panel active">
    <div class="search-row">
      <input type="text" id="objectInput" class="object-input" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: –æ–±—É–≤—å, —á–µ–ª–æ–≤–µ–∫, —Å–æ–±–∞–∫–∞, –º–∞—à–∏–Ω–∞ –∏–ª–∏ –ø–æ-–∞–Ω–≥–ª–∏–π—Å–∫–∏..." autocomplete="off">
      <p class="en-labels" id="enLabels"></p>
    </div>

    <div class="upload-zone" id="uploadZone">
      <input type="file" id="fileInput" accept="image/*">
      <div class="upload-content" id="uploadContent">
        <div class="upload-icon">üì∑</div>
        <p class="upload-text">–ù–∞–∂–º–∏—Ç–µ –∏–ª–∏ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</p>
        <p class="upload-hint">JPG, PNG, WebP</p>
      </div>
      <div class="preview-wrapper" id="previewWrapper" style="display: none;">
        <img id="preview" alt="–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä">
        <canvas id="canvas"></canvas>
      </div>
    </div>

    <div class="controls">
      <button class="btn-detect" id="detectBtn" disabled>–ù–∞–π—Ç–∏ –æ–±—ä–µ–∫—Ç</button>
      <button class="btn-masks" id="masksBtn" disabled>–ú–∞—Å–∫–∏ (SegFormer)</button>
      <button class="btn-clipseg" id="clipsegBtn" disabled>–ú–∞—Å–∫–∞ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é</button>
      <button class="btn-clear" id="clearBtn">–û—á–∏—Å—Ç–∏—Ç—å</button>
    </div>

    <p class="status" id="status"></p>

    <div class="results-card" id="resultsCard" style="display: none;">
      <h3 class="results-title">–û–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã</h3>
      <div class="results-list" id="resultsList"></div>
    </div>
    </div>

    <div id="panel-variants" class="tab-panel">
      <div class="variants-upload" id="variantsUpload">
        <input type="file" id="variantsFileInput" accept=".json" style="display:none">
        <div class="upload-icon">üìÅ</div>
        <p class="upload-text">–ó–∞–≥—Ä—É–∑–∏—Ç–µ Variant.json</p>
        <p class="upload-hint">–∏–ª–∏ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Ñ–∞–π–ª —Å—é–¥–∞</p>
      </div>
      <div class="variants-controls">
        <label>–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞:</label>
        <select id="variantsSort" class="variants-sort">
          <option value="">–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é</option>
          <option value="ctr-asc">CTR ‚Üë</option>
          <option value="ctr-desc" selected>CTR ‚Üì</option>
        </select>
      </div>
      <div id="variantsGrid" class="variants-grid"></div>
    </div>

    <div id="panel-generate" class="tab-panel">
      <details class="gen-howto">
        <summary>–ö–∞–∫ –ø–æ–ª—É—á–∏—Ç—å URL –ø—Ä–æ–∫—Å–∏? (–ø–æ—à–∞–≥–æ–≤–æ)</summary>
        <ol>
          <li>–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å –Ω–∞ <a href="https://replicate.com" target="_blank" rel="noopener">replicate.com</a> –∏ –≤–æ–∑—å–º–∏—Ç–µ API-—Ç–æ–∫–µ–Ω –≤ <a href="https://replicate.com/account/api-tokens" target="_blank" rel="noopener">Account ‚Üí API tokens</a>.</li>
          <li>–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å –Ω–∞ <a href="https://vercel.com" target="_blank" rel="noopener">vercel.com</a>, –Ω–∞–∂–º–∏—Ç–µ <strong>Add New‚Ä¶ ‚Üí Project</strong>.</li>
          <li>–ò–º–ø–æ—Ä—Ç–∏—Ä—É–π—Ç–µ –ø—Ä–æ–µ–∫—Ç: –∑–∞–≥—Ä—É–∑–∏—Ç–µ –ø–∞–ø–∫—É —Å —ç—Ç–∏–º —Å–∞–π—Ç–æ–º (–≥–¥–µ –ª–µ–∂–∞—Ç <code>index.html</code> –∏ –ø–∞–ø–∫–∞ <code>api</code>) –≤ GitHub, –∑–∞—Ç–µ–º –≤ Vercel –≤—ã–±–µ—Ä–∏—Ç–µ —ç—Ç–æ—Ç —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π. –õ–∏–±–æ –Ω–∞–∂–º–∏—Ç–µ <strong>Deploy</strong> –∏ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –ø–∞–ø–∫—É –ø—Ä–æ–µ–∫—Ç–∞ –≤ –æ–∫–Ω–æ (Deploy without Git).</li>
          <li>–ü–µ—Ä–µ–¥ –¥–µ–ø–ª–æ–µ–º –æ—Ç–∫—Ä–æ–π—Ç–µ <strong>Settings ‚Üí Environment Variables</strong>, –¥–æ–±–∞–≤—å—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>REPLICATE_API_TOKEN</code> –∏ –≤—Å—Ç–∞–≤—å—Ç–µ —Ç–æ–∫–µ–Ω –∏–∑ —à–∞–≥–∞ 1. –°–æ—Ö—Ä–∞–Ω–∏—Ç–µ.</li>
          <li>–ù–∞–∂–º–∏—Ç–µ <strong>Deploy</strong>. –î–æ–∂–¥–∏—Ç–µ—Å—å –æ–∫–æ–Ω—á–∞–Ω–∏—è (1‚Äì2 –º–∏–Ω).</li>
          <li>–ù–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ –ø—Ä–æ–µ–∫—Ç–∞ —Å–∫–æ–ø–∏—Ä—É–π—Ç–µ –∞–¥—Ä–µ—Å –≤–∏–¥–∞ <strong>https://–≤–∞—à-–ø—Ä–æ–µ–∫—Ç.vercel.app</strong>. –í –ø–æ–ª–µ –Ω–∏–∂–µ –≤—Å—Ç–∞–≤—å—Ç–µ: <strong>https://–≤–∞—à-–ø—Ä–æ–µ–∫—Ç.vercel.app/api/generate</strong> (–∏–ª–∏ –ø—Ä–æ—Å—Ç–æ <strong>https://–≤–∞—à-–ø—Ä–æ–µ–∫—Ç.vercel.app</strong> ‚Äî –ø–æ–¥—Å—Ç–∞–≤–∏—Ç—Å—è —Å–∞–º–æ).</li>
        </ol>
      </details>
      <div class="gen-section">
        <label>URL –ø—Ä–æ–∫—Å–∏:</label>
        <input type="url" id="genProxyUrl" class="gen-proxy-input" placeholder="https://–≤–∞—à-–ø—Ä–æ–µ–∫—Ç.vercel.app –∏–ª–∏ .../api/generate" autocomplete="off">
      </div>
      <div class="gen-section">
        <label>–ò—Å—Ö–æ–¥–Ω–æ–µ —Ñ–æ—Ç–æ:</label>
        <div class="gen-upload" id="genUpload">
          <input type="file" id="genFileInput" accept="image/*" style="display:none">
          <div id="genUploadPlaceholder">
            <div class="upload-icon">üñºÔ∏è</div>
            <p class="upload-text">–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–æ—Ç–æ</p>
          </div>
          <img id="genPreview" alt="" style="display:none">
        </div>
      </div>
      <div class="gen-section">
        <label>–ú–æ–¥–µ–ª—å:</label>
        <select id="genModel" class="gen-proxy-input">
          <option value="flux_img2img">Flux img2img</option>
          <option value="sdxl">SDXL img2img</option>
          <option value="nano_banana">Google Nano Banana</option>
          <option value="gpt_image_1_5">OpenAI GPT Image 1.5</option>
        </select>
      </div>
      <div class="gen-section gen-settings">
        <label>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –º–æ–¥–µ–ª–∏:</label>
        <div class="gen-settings-grid">
          <div class="gen-setting">
            <label for="genPromptStrength" title="–ù–∞—Å–∫–æ–ª—å–∫–æ —Å–∏–ª—å–Ω–æ –ø—Ä–æ–º–ø—Ç –∏–∑–º–µ–Ω—è–µ—Ç –∏—Å—Ö–æ–¥–Ω–æ–µ —Ñ–æ—Ç–æ. 0.1 = –ø–æ—á—Ç–∏ –Ω–µ –º–µ–Ω—è–µ—Ç, 1 = –ø–æ–ª–Ω–∞—è –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∞.">–°–∏–ª–∞ –ø—Ä–æ–º–ø—Ç–∞ (0.1‚Äì1):</label>
            <input type="number" id="genPromptStrength" min="0.1" max="1" step="0.1" value="0.8" class="gen-setting-input">
            <span class="gen-setting-hint">–°—Ç–µ–ø–µ–Ω—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —Ñ–æ—Ç–æ –ø—Ä–æ–º–ø—Ç–æ–º. 1 = –ø–æ–ª–Ω–∞—è –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∞</span>
          </div>
          <div class="gen-setting">
            <label for="genSteps" title="–ß–µ–º –±–æ–ª—å—à–µ —à–∞–≥–æ–≤ ‚Äî —Ç–µ–º –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–µ–µ, –Ω–æ –¥–æ–ª—å—à–µ.">–®–∞–≥–∏ –≤—ã–≤–æ–¥–∞:</label>
            <input type="number" id="genSteps" min="10" max="50" value="28" class="gen-setting-input">
            <span class="gen-setting-hint">–®–∞–≥–∏ –¥–µ–Ω–æ–π–∑–∏–Ω–≥–∞. –ë–æ–ª—å—à–µ = –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–µ–µ, –Ω–æ –º–µ–¥–ª–µ–Ω–Ω–µ–µ</span>
          </div>
          <div class="gen-setting">
            <label for="genSeed" title="–î–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤. –ü—É—Å—Ç–æ = —Å–ª—É—á–∞–π–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç.">Seed:</label>
            <input type="number" id="genSeed" placeholder="‚Äî" class="gen-setting-input" min="0" step="1">
            <span class="gen-setting-hint">–û–¥–∏–Ω–∞–∫–æ–≤—ã–π seed –¥–∞—ë—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç. –ü—É—Å—Ç–æ = —Å–ª—É—á–∞–π–Ω–æ</span>
          </div>
          <div class="gen-setting gen-setting-wide">
            <label for="genNegativePrompt" title="–ß—Ç–æ –∏—Å–∫–ª—é—á–∏—Ç—å –∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (blurry, ugly –∏ —Ç.–¥.).">–ù–µ–≥–∞—Ç–∏–≤–Ω—ã–π –ø—Ä–æ–º–ø—Ç:</label>
            <input type="text" id="genNegativePrompt" placeholder="blurry, low quality, distorted..." class="gen-setting-input">
            <span class="gen-setting-hint">–°–ª–æ–≤–∞ –∏ —Ñ—Ä–∞–∑—ã, –∫–æ—Ç–æ—Ä—ã—Ö –Ω—É–∂–Ω–æ –∏–∑–±–µ–≥–∞—Ç—å –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ</span>
          </div>
          <div class="gen-setting">
            <label for="genGuidance" title="–ù–∏–∑–∫–æ–µ = –∫—Ä–µ–∞—Ç–∏–≤–Ω–µ–µ, –≤—ã—Å–æ–∫–æ–µ = —Å—Ç—Ä–æ–∂–µ —Å–ª–µ–¥—É–µ—Ç –ø—Ä–æ–º–ø—Ç—É.">Guidance scale:</label>
            <input type="number" id="genGuidance" placeholder="‚Äî" min="1" max="15" step="0.5" class="gen-setting-input">
            <span class="gen-setting-hint">–°—Ç—Ä–æ–≥–æ—Å—Ç—å —Å–ª–µ–¥–æ–≤–∞–Ω–∏—è –ø—Ä–æ–º–ø—Ç—É. Flux: 2‚Äì5, SDXL: 7‚Äì10</span>
          </div>
          <div class="gen-setting">
            <label for="genOutputFormat" title="webp –º–µ–Ω—å—à–µ –ø–æ —Ä–∞–∑–º–µ—Ä—É, png –±–µ–∑ –ø–æ—Ç–µ—Ä—å.">–§–æ—Ä–º–∞—Ç –≤—ã–≤–æ–¥–∞:</label>
            <select id="genOutputFormat" class="gen-setting-input">
              <option value="">–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é</option>
              <option value="webp">WebP</option>
              <option value="png">PNG</option>
            </select>
            <span class="gen-setting-hint">webp –∫–æ–º–ø–∞–∫—Ç–Ω–µ–µ, png –±–µ–∑ –ø–æ—Ç–µ—Ä—å</span>
          </div>
          <div class="gen-setting">
            <label for="genOutputQuality" title="–¢–æ–ª—å–∫–æ –¥–ª—è webp. 80‚Äì90 –æ–±—ã—á–Ω–æ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ.">–ö–∞—á–µ—Å—Ç–≤–æ (webp):</label>
            <input type="number" id="genOutputQuality" placeholder="‚Äî" min="1" max="100" class="gen-setting-input">
            <span class="gen-setting-hint">0‚Äì100, —Ç–æ–ª—å–∫–æ –¥–ª—è WebP. –ü—É—Å—Ç–æ = –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é</span>
          </div>
        </div>
      </div>
      <div class="gen-section">
        <label>–ü—Ä–æ–º–ø—Ç (–Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º –ª—É—á—à–µ):</label>
        <textarea id="genPrompt" class="gen-prompt-input" placeholder="–Ω–∞–ø—Ä–∏–º–µ—Ä: same person in a forest, autumn lighting"></textarea>
      </div>
      <button type="button" class="btn-detect gen-btn" id="genBtn" disabled>–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å</button>
      <p class="status" id="genStatus"></p>
      <div id="genResultWrap" class="gen-result-wrap" style="display:none;">
        <p style="color: var(--text-muted); margin-bottom: 0.5rem;">–†–µ–∑—É–ª—å—Ç–∞—Ç:</p>
        <img id="genResult" alt="–†–µ–∑—É–ª—å—Ç–∞—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏">
      </div>
    </div>
  </div>

  <script type="module">
    import { pipeline, AutoTokenizer, AutoProcessor, AutoModelForImageSegmentation, RawImage } from 'https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.2.0';

    const uploadZone = document.getElementById('uploadZone');
    const fileInput = document.getElementById('fileInput');
    const objectInput = document.getElementById('objectInput');
    const uploadContent = document.getElementById('uploadContent');
    const previewWrapper = document.getElementById('previewWrapper');
    const preview = document.getElementById('preview');
    const canvas = document.getElementById('canvas');
    const detectBtn = document.getElementById('detectBtn');
    const masksBtn = document.getElementById('masksBtn');
    const clipsegBtn = document.getElementById('clipsegBtn');
    const clearBtn = document.getElementById('clearBtn');
    const status = document.getElementById('status');
    const resultsCard = document.getElementById('resultsCard');
    const resultsList = document.getElementById('resultsList');
    const enLabels = document.getElementById('enLabels');

    let detector = null;
    let segmenter = null;
    let clipsegModel = null;
    let clipsegProcessor = null;
    let clipsegTokenizer = null;
    let currentFile = null;

    const MASK_COLORS = ['#7c5cff', '#34d399', '#f59e0b', '#ef4444', '#06b6d4', '#8b5cf6', '#ec4899'];

    // Tabs
    document.querySelectorAll('.tab').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById('panel-' + btn.dataset.tab).classList.add('active');
      });
    });

    // Variants tab
    const variantsUpload = document.getElementById('variantsUpload');
    const variantsFileInput = document.getElementById('variantsFileInput');
    const variantsSort = document.getElementById('variantsSort');
    const variantsGrid = document.getElementById('variantsGrid');
    const VARIANTS_BASE_URL = 'https://f6a3e4b5-e3d8-4b40-af8d-cb29edc59942.selstorage.ru/';

    variantsUpload.addEventListener('click', () => variantsFileInput.click());

    variantsUpload.addEventListener('dragover', (e) => {
      e.preventDefault();
      variantsUpload.style.borderColor = 'var(--accent)';
    });

    variantsUpload.addEventListener('dragleave', () => {
      variantsUpload.style.borderColor = '';
    });

    variantsUpload.addEventListener('drop', (e) => {
      e.preventDefault();
      variantsUpload.style.borderColor = '';
      const file = e.dataTransfer?.files?.[0];
      if (file?.name?.endsWith('.json')) handleVariantsFile(file);
    });

    variantsFileInput.addEventListener('change', (e) => {
      const file = e.target.files?.[0];
      if (file) handleVariantsFile(file);
      e.target.value = '';
    });

    let variantsItems = [];

    function getSortedVariants() {
      const sort = variantsSort?.value || 'ctr-desc';
      if (!sort || variantsItems.length === 0) return variantsItems;
      const arr = [...variantsItems];
      if (sort === 'ctr-asc') arr.sort((a, b) => (a.ctr ?? 0) - (b.ctr ?? 0));
      if (sort === 'ctr-desc') arr.sort((a, b) => (b.ctr ?? 0) - (a.ctr ?? 0));
      return arr;
    }

    function handleVariantsFile(file) {
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const data = JSON.parse(reader.result);
          variantsItems = Array.isArray(data) ? data : (data.items || data.data || []);
          renderVariants(getSortedVariants());
        } catch (err) {
          alert('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è JSON: ' + err.message);
        }
      };
      reader.readAsText(file, 'UTF-8');
    }

    variantsSort?.addEventListener('change', () => {
      if (variantsItems.length) renderVariants(getSortedVariants());
    });

    // Generation tab
    const genProxyUrl = document.getElementById('genProxyUrl');
    const genPrompt = document.getElementById('genPrompt');

    try {
      const savedProxy = localStorage.getItem('ai-vision-proxy-url');
      if (savedProxy) genProxyUrl.value = savedProxy;
      const savedPrompt = localStorage.getItem('ai-vision-prompt');
      if (savedPrompt) genPrompt.value = savedPrompt;
    } catch (_) {}

    genProxyUrl?.addEventListener('blur', () => {
      try { localStorage.setItem('ai-vision-proxy-url', genProxyUrl.value || ''); } catch (_) {}
    });
    genPrompt?.addEventListener('blur', () => {
      try { localStorage.setItem('ai-vision-prompt', genPrompt.value || ''); } catch (_) {}
    });

    const genUpload = document.getElementById('genUpload');
    const genFileInput = document.getElementById('genFileInput');
    const genUploadPlaceholder = document.getElementById('genUploadPlaceholder');
    const genPreview = document.getElementById('genPreview');
    const genBtn = document.getElementById('genBtn');
    const genStatus = document.getElementById('genStatus');
    const genResultWrap = document.getElementById('genResultWrap');
    const genResult = document.getElementById('genResult');

    let genImageDataUrl = null;

    genUpload.addEventListener('click', () => genFileInput.click());
    function compressImageForReplicate(dataUrl, maxSize = 1024, quality = 0.82) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          let w = img.width, h = img.height;
          if (w > maxSize || h > maxSize) {
            if (w > h) { h = Math.round(h * maxSize / w); w = maxSize; }
            else { w = Math.round(w * maxSize / h); h = maxSize; }
          }
          const canvas = document.createElement('canvas');
          canvas.width = w;
          canvas.height = h;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, w, h);
          const out = canvas.toDataURL('image/jpeg', quality);
          resolve(out);
        };
        img.onerror = () => resolve(dataUrl);
        img.src = dataUrl;
      });
    }

    genFileInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file || !file.type.startsWith('image/')) return;
      const reader = new FileReader();
      reader.onload = async () => {
        const raw = reader.result;
        genImageDataUrl = await compressImageForReplicate(raw);
        genPreview.src = genImageDataUrl;
        genPreview.style.display = 'block';
        genUploadPlaceholder.style.display = 'none';
        genUpload.classList.add('has-image');
        updateGenBtn();
      };
      reader.readAsDataURL(file);
    });

    function updateGenBtn() {
      const hasProxy = (genProxyUrl?.value || '').trim().length > 0;
      genBtn.disabled = !hasProxy || !genImageDataUrl || !(genPrompt?.value || '').trim();
    }
    genProxyUrl?.addEventListener('input', updateGenBtn);
    genPrompt?.addEventListener('input', updateGenBtn);

    genBtn?.addEventListener('click', async () => {
      let base = (genProxyUrl?.value || '').trim().replace(/\/+$/, '');
      if (!base || !genImageDataUrl || !(genPrompt?.value || '').trim()) return;
      if (!/^https?:\/\//i.test(base)) base = 'https://' + base;
      const url = base + (base.endsWith('/api/generate') ? '' : '/api/generate');
      genStatus.textContent = '–ì–µ–Ω–µ—Ä–∞—Ü–∏—è...';
      genResultWrap.style.display = 'none';
      genBtn.disabled = true;
      try {
        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: genPrompt.value.trim(),
            image: genImageDataUrl,
            model: (document.getElementById('genModel')?.value || 'flux_img2img'),
            prompt_strength: parseFloat(document.getElementById('genPromptStrength')?.value) || 0.8,
            num_inference_steps: parseInt(document.getElementById('genSteps')?.value, 10) || 28,
            seed: (() => { const v = document.getElementById('genSeed')?.value; return v === '' || v === null ? undefined : parseInt(v, 10); })(),
            negative_prompt: (document.getElementById('genNegativePrompt')?.value || '').trim() || undefined,
            guidance_scale: (() => { const v = document.getElementById('genGuidance')?.value; return v === '' ? undefined : parseFloat(v); })(),
            output_format: (document.getElementById('genOutputFormat')?.value || '').trim() || undefined,
            output_quality: (() => { const v = document.getElementById('genOutputQuality')?.value; return v === '' ? undefined : parseInt(v, 10); })()
          })
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          if (res.status === 402) {
            throw new Error('–ù–∞ Replicate –∑–∞–∫–æ–Ω—á–∏–ª—Å—è –∫—Ä–µ–¥–∏—Ç. –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å: replicate.com/account/billing');
          }
          const msg = data.error || data.detail || res.statusText || res.status;
          throw new Error(res.status + ' ‚Äî ' + (typeof msg === 'string' ? msg : JSON.stringify(msg)));
        }
        let imageUrl = data.image_url ?? data.output?.[0] ?? data.url;
        if (imageUrl) {
          genResult.src = imageUrl;
          genResultWrap.style.display = 'block';
          genStatus.textContent = '';
        } else if (data.prediction_id) {
          const statusBase = base.replace(/\/api\/generate\/?$/, '').replace(/\/+$/, '') || base;
            const statusUrl = statusBase + (statusBase.endsWith('/api') ? '/status' : '/api/status');
          const maxWait = 300;
          for (let i = 0; i < maxWait; i++) {
            const s = i + 1;
            genStatus.textContent = s >= 60 ? `–ì–µ–Ω–µ—Ä–∞—Ü–∏—è... ${Math.floor(s / 60)} –º–∏–Ω ${s % 60} —Å (–º–∞–∫—Å. 5 –º–∏–Ω)` : `–ì–µ–Ω–µ—Ä–∞—Ü–∏—è... ${s} —Å`;
            await new Promise(r => setTimeout(r, 1000));
            const statusRes = await fetch(statusUrl + '?id=' + encodeURIComponent(data.prediction_id));
            const statusData = await statusRes.json().catch(() => ({}));
            if (statusData.status === 'succeeded' && statusData.image_url) {
              genResult.src = statusData.image_url;
              genResultWrap.style.display = 'block';
              genStatus.textContent = '';
              break;
            }
            if (statusData.status === 'failed' || statusData.status === 'canceled') {
              throw new Error(statusData.error || statusData.status || '–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å');
            }
          }
          if (!genResultWrap.style.display || genResultWrap.style.display === 'none') {
            genStatus.textContent = '–¢–∞–π–º–∞—É—Ç (5 –º–∏–Ω). –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥—É—é –º–æ–¥–µ–ª—å.';
          }
        } else {
          genStatus.textContent = '–í –æ—Ç–≤–µ—Ç–µ –Ω–µ—Ç URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è';
        }
      } catch (err) {
        genStatus.textContent = '–û—à–∏–±–∫–∞: ' + err.message;
      }
      genBtn.disabled = false;
      updateGenBtn();
    });

    function renderVariants(items) {
      variantsGrid.innerHTML = items.map(item => {
        const src = item.photo_path ? VARIANTS_BASE_URL + item.photo_path : '';
        const ctr = item.ctr != null ? item.ctr.toFixed(2) : '‚Äî';
        const views = item.views != null ? String(item.views) : '‚Äî';
        const abtest = item.abtest_id != null ? String(item.abtest_id) : '‚Äî';
        return `<div class="variant-card">
          <img src="${src}" alt="" loading="lazy" onerror="this.src='';this.alt='–ù–µ—Ç —Ñ–æ—Ç–æ'">
          <div class="variant-badges">
            <span class="variant-badge ctr">ctr: ${ctr}</span>
            <span class="variant-badge views">views: ${views}</span>
            <span class="variant-badge abtest">abtest_id: ${abtest}</span>
          </div>
        </div>`;
      }).join('');
    }

    uploadZone.addEventListener('click', () => fileInput.click());

    uploadZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadZone.classList.add('dragover');
    });

    uploadZone.addEventListener('dragleave', () => {
      uploadZone.classList.remove('dragover');
    });

    uploadZone.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadZone.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file && file.type.startsWith('image/')) handleFile(file);
    });

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) handleFile(file);
    });

    objectInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') detect();
    });

    function handleFile(file) {
      currentFile = file;
      const reader = new FileReader();
      reader.onload = (e) => {
        preview.src = e.target.result;
        uploadContent.style.display = 'none';
        previewWrapper.style.display = 'block';
        uploadZone.classList.add('has-image');
        detectBtn.disabled = false;
        masksBtn.disabled = false;
        clipsegBtn.disabled = false;
        resultsCard.style.display = 'none';
        clearCanvas();
      };
      reader.readAsDataURL(file);
    }

    function setStatus(text, type = '') {
      status.textContent = text;
      status.className = 'status' + (type ? ` ${type}` : '');
    }

    function clearCanvas() {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    const MYMEMORY_URL = 'https://api.mymemory.translated.net/get';

    async function checkMyMemory() {
      try {
        const res = await fetch(`${MYMEMORY_URL}?q=${encodeURIComponent('—Ç–µ—Å—Ç')}&langpair=ru|en`);
        const data = await res.json();
        const out = data?.responseData?.translatedText;
        const ok = out && !/[–∞-—è—ë]/i.test(out);
        console.log('MyMemory:', ok ? 'OK ‚Äî ' + out : 'FAIL ‚Äî ' + JSON.stringify(data));
        return ok;
      } catch (e) {
        console.log('MyMemory:', 'ERROR ‚Äî', e.message);
        return false;
      }
    }

    async function translateRuToEn(text) {
      if (!/[–∞-—è—ë]/i.test(text)) return text;
      const res = await fetch(`${MYMEMORY_URL}?q=${encodeURIComponent(text)}&langpair=ru|en`);
      const data = await res.json();
      const out = data?.responseData?.translatedText || text;
      if (/[–∞-—è—ë]/i.test(out)) throw new Error('–ü–µ—Ä–µ–≤–æ–¥ –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω: –æ—Ç–≤–µ—Ç –Ω–∞ —Ä—É—Å—Å–∫–æ–º');
      return out;
    }

    function toModelLabels(s, display) {
      const w = s.replace(/\s+/g, ' ').trim().toLowerCase();
      if (!/^[a-z\s-]+$/.test(w)) return { labels: [w], display: { [w]: display } };
      const singular = w.endsWith('s') && w.length > 2 ? 'a ' + w.slice(0, -1) : null;
      const withA = !w.includes(' ') && !w.endsWith('s') ? 'a ' + w : null;
      const labels = [...new Set([singular, withA, w].filter(Boolean))];
      const disp = {};
      labels.forEach(l => { disp[l] = display; });
      return { labels, display: disp };
    }

    async function formatLabels(text) {
      const raw = text.trim().split(/[,;]+/).map(s => s.trim()).filter(Boolean);
      const hasRu = raw.some(s => /[–∞-—è—ë]/i.test(s));
      let enRaw = raw;
      if (hasRu) {
        const translated = await translateRuToEn(raw.join(', '));
        enRaw = translated.split(/[,;]+/).map(s => s.trim().toLowerCase()).filter(Boolean);
        if (enRaw.length !== raw.length) enRaw = [translated.toLowerCase()];
      } else {
        enRaw = raw.map(s => s.toLowerCase());
      }
      let forModel = [];
      const forDisplay = {};
      enRaw.forEach((en, i) => {
        const { labels, display } = toModelLabels(en, raw[i] || en);
        forModel = forModel.concat(labels);
        Object.assign(forDisplay, display);
      });
      forModel = [...new Set(forModel)];
      return { forModel, forDisplay };
    }

    async function loadCLIPSeg() {
      if (clipsegModel) return { model: clipsegModel, processor: clipsegProcessor, tokenizer: clipsegTokenizer };
      setStatus('–ó–∞–≥—Ä—É–∑–∫–∞ CLIPSeg (~160 –ú–ë)...', 'loading');
      [clipsegTokenizer, clipsegProcessor, clipsegModel] = await Promise.all([
        AutoTokenizer.from_pretrained('Xenova/clipseg-rd64'),
        AutoProcessor.from_pretrained('Xenova/clipseg-rd64'),
        AutoModelForImageSegmentation.from_pretrained('Xenova/clipseg-rd64')
      ]);
      return { model: clipsegModel, processor: clipsegProcessor, tokenizer: clipsegTokenizer };
    }

    async function runCLIPSeg() {
      const query = objectInput.value.trim();
      if (!query) {
        setStatus('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞.');
        return;
      }
      if (!preview.src || preview.src === window.location.href) {
        setStatus('–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.');
        return;
      }
      if (/[–∞-—è—ë]/i.test(query)) setStatus('–ü–µ—Ä–µ–≤–æ–¥...', 'loading');
      const { forModel: labels } = await formatLabels(query);
      enLabels.textContent = labels.length ? '–ú–∞—Å–∫–∞ –¥–ª—è: ' + labels.join(', ') : '';
      if (!labels.length) return;
      clipsegBtn.disabled = true;
      setStatus('–ú–∞—Å–∫–∞ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é...', 'loading');
      try {
        const { model, processor, tokenizer } = await loadCLIPSeg();
        const image = await RawImage.read(preview.src);
        const textInputs = tokenizer(labels, { padding: true, truncation: true });
        const imageInputs = await processor(image);
        const out = await model({ ...textInputs, ...imageInputs });
        const logits = out.logits || out;
        let preds = logits;
        if (typeof logits.sigmoid === 'function') preds = logits.sigmoid();
        else preds = { data: Array.from(logits.data).map(v => 1 / (1 + Math.exp(-v))), dims: logits.dims };
        if (typeof preds.mul === 'function') preds = preds.mul(255).round();
        else preds = { data: preds.data.map(v => Math.round(Math.min(255, Math.max(0, v * 255)))), dims: preds.dims };
        const rect = preview.getBoundingClientRect();
        const dispW = Math.round(rect.width);
        const dispH = Math.round(rect.height);
        const dims = preds.dims || preds.size || [1, 352, 352];
        const maskH = dims[1] || 352;
        const maskW = dims[2] || 352;
        const data = Array.isArray(preds.data) ? preds.data : (preds.data ? Array.from(preds.data) : []);
        canvas.width = dispW;
        canvas.height = dispH;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(preview, 0, 0, dispW, dispH);
        const imgData = ctx.getImageData(0, 0, dispW, dispH);
        const r = 124, g = 92, b = 255;
        const blend = 0.5;
        for (let y = 0; y < dispH; y++) {
          for (let x = 0; x < dispW; x++) {
            const sx = Math.min(Math.floor(x * maskW / dispW), maskW - 1);
            const sy = Math.min(Math.floor(y * maskH / dispH), maskH - 1);
            let v = 0;
            const nT = dims[0] || 1;
            for (let t = 0; t < nT; t++) {
              const idx = t * maskH * maskW + sy * maskW + sx;
              v = Math.max(v, data[idx] ?? 0);
            }
            if (v > 128) {
              const i = (y * dispW + x) * 4;
              imgData.data[i] = imgData.data[i] * (1 - blend) + r * blend;
              imgData.data[i + 1] = imgData.data[i + 1] * (1 - blend) + g * blend;
              imgData.data[i + 2] = imgData.data[i + 2] * (1 - blend) + b * blend;
            }
          }
        }
        ctx.putImageData(imgData, 0, 0);
        resultsCard.style.display = 'block';
        resultsList.innerHTML = labels.map(l => `
          <div class="result-item">
            <span class="result-class">${l}</span>
            <span style="width:12px;height:12px;border-radius:2px;background:#7c5cff"></span>
          </div>
        `).join('');
        setStatus('–ú–∞—Å–∫–∞ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –ø–æ—Å—Ç—Ä–æ–µ–Ω–∞', 'success');
      } catch (err) {
        setStatus('–û—à–∏–±–∫–∞: ' + err.message);
        console.error(err);
      }
      clipsegBtn.disabled = false;
    }

    async function loadSegmenter() {
      if (segmenter) return segmenter;
      setStatus('–ó–∞–≥—Ä—É–∑–∫–∞ SegFormer (~50 –ú–ë)...', 'loading');
      segmenter = await pipeline('image-segmentation', 'Xenova/segformer-b0-finetuned-ade-512-512', { dtype: 'q8' });
      return segmenter;
    }

    async function runMasks() {
      if (!preview.src || preview.src === window.location.href) {
        setStatus('–°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.');
        return;
      }
      const seg = await loadSegmenter();
      setStatus('–°–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è...', 'loading');
      masksBtn.disabled = true;
      try {
        const output = await seg(preview.src);
        const rect = preview.getBoundingClientRect();
        const dispW = Math.round(rect.width);
        const dispH = Math.round(rect.height);
        canvas.width = dispW;
        canvas.height = dispH;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(preview, 0, 0, dispW, dispH);
        const imgData = ctx.getImageData(0, 0, dispW, dispH);
        const topMasks = output.slice(0, 7);
        topMasks.forEach((item, idx) => {
          if (!item.mask) return;
          const m = item.mask;
          const w = m.width ?? m.size?.[0] ?? 512;
          const h = m.height ?? m.size?.[1] ?? 512;
          const d = m.data;
          if (!d || d.length === 0) return;
          const hex = MASK_COLORS[idx].replace('#', '');
          const r = parseInt(hex.slice(0, 2), 16), g = parseInt(hex.slice(2, 4), 16), b = parseInt(hex.slice(4, 6), 16);
          const scaleX = w / dispW, scaleY = h / dispH;
          const ch = d.length / (w * h);
          const blend = 0.5;
          for (let y = 0; y < dispH; y++) {
            for (let x = 0; x < dispW; x++) {
              const sx = Math.min(Math.floor(x * scaleX), w - 1);
              const sy = Math.min(Math.floor(y * scaleY), h - 1);
              const vi = ch <= 1 ? sy * w + sx : (sy * w + sx) * ch;
              const v = d[Math.min(Math.floor(vi), d.length - 1)];
              const i = (y * dispW + x) * 4;
              if (v > 128) {
                imgData.data[i] = imgData.data[i] * (1 - blend) + r * blend;
                imgData.data[i + 1] = imgData.data[i + 1] * (1 - blend) + g * blend;
                imgData.data[i + 2] = imgData.data[i + 2] * (1 - blend) + b * blend;
              }
            }
          }
        });
        ctx.putImageData(imgData, 0, 0);
        resultsCard.style.display = 'block';
        resultsList.innerHTML = topMasks.map((o, i) => `
          <div class="result-item">
            <span class="result-class">${o.label}</span>
            <span style="width:12px;height:12px;border-radius:2px;background:${MASK_COLORS[i]}"></span>
          </div>
        `).join('');
        setStatus(`–°–µ–≥–º–µ–Ω—Ç–æ–≤: ${output.length}`, 'success');
      } catch (err) {
        setStatus('–û—à–∏–±–∫–∞: ' + err.message);
      }
      masksBtn.disabled = false;
    }

    async function loadDetector() {
      if (detector) return detector;
      setStatus('–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏ OWL-ViT (~180 –ú–ë)...', 'loading');
      try {
        detector = await pipeline('zero-shot-object-detection', 'Xenova/owlvit-base-patch32', { dtype: 'q8' });
        setStatus('–ú–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞. –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏ –≤–≤–µ–¥–∏—Ç–µ –æ–±—ä–µ–∫—Ç –¥–ª—è –ø–æ–∏—Å–∫–∞.');
        return detector;
      } catch (err) {
        setStatus('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ' + err.message);
        detector = null;
        throw err;
      }
    }

    async function detect() {
      const query = objectInput.value.trim();
      if (!query) {
        setStatus('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞.');
        return;
      }
      if (!preview.src || preview.src === window.location.href || !currentFile) {
        setStatus('–°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.');
        return;
      }

      const d = await loadDetector();
      detectBtn.disabled = true;

      try {
        if (/[–∞-—è—ë]/i.test(query)) setStatus('–ü–µ—Ä–µ–≤–æ–¥ —á–µ—Ä–µ–∑ MyMemory...', 'loading');
        const { forModel: labels, forDisplay } = await formatLabels(query);
        enLabels.textContent = labels.length ? '–ò—â–µ–º –Ω–∞ –∞–Ω–≥–ª.: ' + labels.join(', ') : '';
        setStatus('–ü–æ–∏—Å–∫ –æ–±—ä–µ–∫—Ç–æ–≤...', 'loading');
        if (!labels.length) {
          setStatus('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞.');
          detectBtn.disabled = false;
          return;
        }
        const output = await d(preview.src, labels, { threshold: 0.12, top_k: 15 });

        const rect = preview.getBoundingClientRect();
        const dispW = Math.round(rect.width);
        const dispH = Math.round(rect.height);
        const natW = preview.naturalWidth;
        const natH = preview.naturalHeight;
        const scaleX = natW / dispW;
        const scaleY = natH / dispH;

        canvas.width = dispW;
        canvas.height = dispH;
        canvas.style.width = dispW + 'px';
        canvas.style.height = dispH + 'px';

        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        output.forEach((p, idx) => {
          const { xmin, ymin, xmax, ymax } = p.box;
          const boxW = xmax - xmin;
          const boxH = ymax - ymin;
          const pctW = (boxW / natW * 100).toFixed(1);
          const pctH = (boxH / natH * 100).toFixed(1);
          const pctArea = (boxW * boxH / (natW * natH) * 100).toFixed(1);
          p._size = { pctW, pctH, pctArea };

          let sx = xmin / scaleX;
          let sy = ymin / scaleY;
          let sw = boxW / scaleX;
          let sh = boxH / scaleY;
          sx = Math.max(0, Math.min(sx, dispW - 2));
          sy = Math.max(0, Math.min(sy, dispH - 2));
          sw = Math.min(sw, dispW - sx);
          sh = Math.min(sh, dispH - sy);
          if (sw <= 0 || sh <= 0) return;

          const isBest = idx === 0;
          const boxColor = isBest ? '#34d399' : '#7c5cff';
          ctx.strokeStyle = boxColor;
          ctx.lineWidth = isBest ? 3 : 2;
          ctx.strokeRect(sx, sy, sw, sh);

          ctx.fillStyle = boxColor;
          ctx.font = '12px Outfit, sans-serif';
          const displayLabel = forDisplay[p.label] || p.label;
          const label = `${displayLabel} ${(p.score * 100).toFixed(0)}% ¬∑ ${pctArea}% –∫–∞–¥—Ä–∞`;
          const textWidth = ctx.measureText(label).width;
          ctx.fillRect(sx, sy - 20, textWidth + 8, 20);
          ctx.fillStyle = 'white';
          ctx.fillText(label, sx + 4, sy - 6);
        });

        resultsList.innerHTML = output.map((p, idx) => {
          const s = p._size || { pctW: '-', pctH: '-', pctArea: '-' };
          const isBest = idx === 0;
          return `
          <div class="result-item${isBest ? ' result-item-best' : ''}">
            <div>
              <span class="result-class">${forDisplay[p.label] || p.label}${isBest ? ' ‚úì –ª—É—á—à–∏–π' : ''}</span>
              <div class="result-size">${s.pctW}% √ó ${s.pctH}% –∫–∞–¥—Ä–∞, ${s.pctArea}% –ø–ª–æ—â–∞–¥–∏</div>
            </div>
            <span class="result-confidence">${(p.score * 100).toFixed(1)}%</span>
          </div>
        `;
        }).join('');

        resultsCard.style.display = 'block';
        setStatus(`–ù–∞–π–¥–µ–Ω–æ: ${output.length}`, 'success');
      } catch (err) {
        setStatus('–û—à–∏–±–∫–∞: ' + err.message);
      }

      detectBtn.disabled = false;
    }

    function clear() {
      fileInput.value = '';
      currentFile = null;
      objectInput.value = '';
      enLabels.textContent = '';
      preview.src = '';
      uploadContent.style.display = 'block';
      previewWrapper.style.display = 'none';
      uploadZone.classList.remove('has-image');
      detectBtn.disabled = true;
      masksBtn.disabled = true;
      clipsegBtn.disabled = true;
      resultsCard.style.display = 'none';
      resultsList.innerHTML = '';
      clearCanvas();
      setStatus('');
    }

    detectBtn.addEventListener('click', detect);
    masksBtn.addEventListener('click', runMasks);
    clipsegBtn.addEventListener('click', runCLIPSeg);
    clearBtn.addEventListener('click', clear);

    checkMyMemory().then(ok => {
      if (ok) setStatus('MyMemory: –¥–æ—Å—Ç—É–ø–µ–Ω');
      else setStatus('MyMemory: –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (—Å–º. –∫–æ–Ω—Å–æ–ª—å F12)');
    });
  </script>
</body>
</html>
